# My_notes

## 기초

### 실수 입력받아 원하는 소수점까지 출력

``` python
a = float(input())

print('%.2f' % a)
```



### print() 속성 'sep=' 사용시 출력값 사이에 특정 문자 넣어 구분 가능

``` python
print(5, 9, sep=":")
```



### 원하는 길이만큼 출력(공백 0으로 채움)

``` python
y, m, d = map(int, input().split("."))

print('%04d' %y, '%02d' %m, '%02d' %d, sep=".")
```



### 2, 8, 16 진수

#### format 이용

``` python
a = format(int(input()), 'o') # 'b' 'o' 'x'

print(a)
```



#### print로 바로 출력

``` python
a = int(input())

print('%x' %a) # '%X' 대문자 사용시 대문자로 출력
```



#### 입력받은 진수와 다른 진수로 출력

``` python
a = input()

n = int(a,16) # a를 16진수로 반꾼 값을 10진수로 변경해서 저장

print("%o" % n) # n을 8진수로 출력
```



### ord() 문자의 아스키 코드 값을 반환(영문자 -> 아스키 10진수)

```python
a = input()

n = ord(a)

print(n)
```



### 10진수 -> 아스키 문자

``` python
a = input()

n = int(a)

c = chr(n)

print(c)
```



### 배열을 정렬한 후 조합을 실행하면 결과도 정렬이 된 상태로 나온다



### 2차원 배열에 값 입력 받기

``` python
a = [[0]*19 for i in range(19)]

for i in range(19):
    x = list(map(int, input().split()))
    for j in range(19):
        a[i][j] = x[j]
```



### 문자열 철자 하나씩 나누기

``` python
s = "hello"
print(s)

# 결과
 'h', 'e', 'l', 'l', 'o'
```



### list내에서 특정 문자의 인덱스 찾기

``` python
s = ['a', 'b']

idx = s.index('a')

# 실행시 idx = 0 반환
```



### join()

> 리스트에 특정 구분자를 추가하여 문자열로 변환함



```python
lst = ['a', 'b', 'c']
print( ",".join(lst) )
print(''.join(lst))

# 결과
a,b,c
abc
```

----



## Greedy

> 현재 상황에서 지금 당장 좋은 것만 고르는 방법
>
> 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.



### 특징

---

- 창의력을 요함, 특정한 문제를 만났을 때 단순히 현재 상황에서 가장 좋아 보이는 것만을 선택해도 문제를 풀 수 있는지를 파악할 수 있어야 한다.
- '가장 큰 순서대로', '가장 작은 순서대로'와 같은 기준을 알게 모르게 제시해준다.
- 그리디 알고리즘 문제는 정렬 알고리즘과 짝을 이뤄 자주 출제된다.
- 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 한다.



--------------



## Implementation

> 구현이란 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정



### 특징

---

- 프로그래밍 언어의 문법을 정확히 알고 있어야 하며 문제의 요구사항에 어긋나지 않는 답안 코드를 작성해야 한다.
- 구현 유형의 문제 : 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제
- 구현하기 어려운 문제
  - 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제
  - 특정 소수점 자리까지 출력해야 하는 문제
  - 문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에 넣어야 하는(파싱을 해야 하는) 문제
- 대체로 사소한 조건 설정이 많은 문제일수록 코드로 구현하기가 까다롭다.
- 완전 탐색, 시뮬레이션 유형을 모두 구현유형으로 묶어서 다룬다

### 완전탐색 / 시뮬레이션

----

> 두 유형 모두 구현이 핵심

- 완전 탐색 : 모든 경우의 수를 주저 없이 다 계산하는 해결 방법(확인(탐색)해야 할 전체 데이터 개수가 100만 개 이하일 때 완전탐색을 사용하면 적절하다.)
- 시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행



### 구현시 고려해야 할 메모리 제약 사항

---

#### C/C++에서 변수의 표현 범위

정수형 int 자료형을 주로 사용하며 이 자료형의 크기는 4바이트이다. 기본 int 자료형의 표현 범위는 -2147483648 ~ 2147438647 이다.

더 큰 수를 처리하기 위해서는 8바이트인 long long과 같은 자료형을 사용

훨씬 큰 수를 담을 변수를 만들려면 흔히 BigInteger 클래스를 구현하거나 이용해야 한다.

자바의 경우 BigInteger를 표준 라이브러리로 지원

| 정수형 종류        | 자료형의 크기 | 자료형의 범위                                          |
| :----------------- | :------------ | ------------------------------------------------------ |
| int                | 4바이트       | -2,147,483,648 ~ 2,147,438,647                         |
| long long          | 8바이트       | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |
| BigInteger(클래스) | 가변적        | 제한 없음                                              |



##### 파이썬에서 리스트 크기

리스트를 이용할 때에 코딩 테스트의 메모리 제한을 고려해야 한다.

int 자료형 데이터의 개수에 따른 메모리 사용량

| 데이터의 개수(리스트의 길이) | 메모리 사용량 |
| ---------------------------- | ------------- |
| 1,000                        | 약 4KB        |
| 1,000,000                    | 약 4MB        |
| 10,000,000                   | 약 40MB       |



#### 구현 문제에 접근하는 방법

---

- 보통 구현 유형의 문제는 사소한 입력 조건 등을 문제에서 명시해주며 문제의 길이가 꽤 긴 편이다.
- 고차원적인 사고력을 요구하는 문제는 나오지 않는 편이라 문법에 익숙하다면 쉽게 풀 수 있다.
- 문자열을 처리하거나 큰 수를 처리하는 문제가 출제되는 경우가 많다.



**Pypy3**

> 파이썬3의 문법을 그대로 지원하며, 대부분 파이썬3보다 실행 속도가 더 빠르다.
>
> 코딩테스트에서 Pypy3를 선택한다면 파이썬3와 동일한 코드를 제출해서 실행 시간을 줄일 수 있다.
>
> 반복문이 많을수록 Pypy3와 파이썬3의 속도가 차이 난다.





---





## DFS/BFS

> 그래프를 탐색하기 위한 대표적인 두 가지 알고리즘



### 탐색

- 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정을 의미
- 프로그래밍에서는 그래프, 트리 등의 자료구조 안에서 탐색을 하는 문제를 자주 다룬다.
- 대표적인 탐색 알고리즘 > DFS, BFS



### 자료구조

- 데이터를 표현하고 관리하고 처리하기 위한 구조를 의미
- 스택과 큐는 자료구조의 기초 개념으로 두 핵심적인 함수로 구성
  - 삽입(Push) : 데이터를 삽입
  - 삭제(Pop) : 데이터를 삭제
  - 오버플로(Overflow) : 특정한 자료구조가 수용할 수 있는 데이터의 크기를 이미 가득 찬 상태에서 삽입 연산을 수행할 때 발생
  - 언더플로(Underflow) : 특정한 자료구조에 데이터가 전혀 들어 있지 않은 상태에서 삭제 연산을 수행하면 발생



### 스택

- 스택(Stack)은 선입후출(First In Last Out) 구조 또는 후입선출(Last In First Out) 구조라고 한다.
- 파이썬에서 스택을 이용할 때에는 별도의 라이브러리를 사용할 필요가 없다.
- 기본 리스트에서 append()와 pop() 메서드를 이용하면 스택 자료구조와 동일하게 동작한다.



``` python
stack = []

stack.append(5)
stack.append(2)
stack.append(3)
stack.append(7)
stack.pop()
stack.append(1)
stack.append(4)
stack.pop()

print(stack) # 최하단 원소부터 출력
print(stack[::-1]) # 최상단 원소부터 출력

# 결과
[5, 2, 3, 1]
[1, 3, 2, 5]
```



### 큐

- 큐(Queue)는 선입선출(First In First Out) 구조라고 한다.
- 파이썬으로 큐를 구현할 때는 collections 모듈에서 제공하는 deque 자료구조를 활용
- deque는 스택과 큐의 장점을 모두 채택한 것인데 데이터를 넣고 빼는 속도가 리스트 자료형에 비해 효율적이며 queue 라이브러리를 이용하는 것보다 간단하다.
- 대부분의 코딩 테스트에서는 collections 모듈과 같은 기본 라이브러리 사용을 허용



``` python
from collections import deque

# 큐(Queue) 구현을 위해 deque 라이브러리 사용
queue = deque()

queue.append(5)
queue.append(2)
queue.append(3)
queue.append(7)
queue.popleft()
queue.append(1)
queue.append(4)
queue.popleft()

print(queue) # 먼저 들어온 순서대로 출력
queue.reverse() # 다음 출력을 위해 역순으로 바꾸기
print(queue) # 나중에 들어온 원소부터 출력

# 결과
deque([3, 7, 1, 4])
deque([4, 1, 7, 3])
```



### 재귀 함수

- 재귀함수란(Recursive Function)란 자기 자신을 다시 호출하는 함수를 의미

``` python
def recursive_function():
    print('재귀 함수 호출')
    recursive_function()
    
recursive_function()
```



#### 재귀 함수의 종료 조건

- 재귀 함수를 문제 풀이에서 사용할 때는 재귀 함수가 언제 끝날지, 종료 조건을 꼭 명시해야 한다.

``` python
def recursive_function(i):
    # 100번째 출력했을 때 종료되도록 종료 조건 명시
    if i == 100:
        return
    print(i, '번째 재귀 함수에서', i + 1, '번째 재귀 함수를 호출합니다')
    recursive_function(i + 1)
    print(i, '번째 재귀 함수를 종료')

recursive_function(1)
```

- 컴퓨터 내부에서 재귀 함수의 수행은 스택 자료구조를 이용한다. 함수를 계속 호출했을 때 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수 호출이 종료되기 때문이다.

``` python
# 재귀 함수를 이용한 대표적 예제 팩토리얼(Factorial) 두 가지 방식

# 반복적으로 구현한 n!
def factorial_iterative(n):
    result = 1
    # 1부터 n까지의 수를 차례대로 곱하기
    for i in range(1, n + 1):
        result *= i
    return result

# 재귀적으로 구현한 n!
def factorial_recursive(n): # n이 1 이하인 경우 1을 반환
    if n <= 1:
        return 1
    # n! = n * (n - 1)!를 그대로 코드로 작성하기
    return n * factorial_recursive(n - 1)

print('반복적으로 구현:', factorial_iterative(5))
print('재귀적으로 구현:', factorial_recursive(5))

# 결과
반복적으로 구현: 120
재귀적으로 구현: 120
```

- 반복문 대신 재귀 함수를 사용하면 코드가 더 간결하다. 이유는 재귀 함수가 수학의 점화식(재귀식)을 그대로 소스코드로 옮겼기 때문이다.
  - 수학에서 점화식은 특정한 함수를 자신보다 더 작은 변수에 대한 함수와의 관계로 표현한 것을 의미한다.
- 재귀 함수 내에서 특정 조건일 때 더 이상 재귀적으로 함수를 호출하지 않고 종료하도록 if문을 이용해 종료 조건을 구현해주어야 한다.



### DFS

>Depth-First Search, 깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.



#### 그래프

- 그래프는 노드(Node)와 간선(Edge)으로 표현되며 이때 노드를 정점(Vertex)이라고도 말한다.
- 그래프 탐색이란 하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말한다.
- 두 노드가 간선으로 연결되어 있다면 '두 노드는 인접하다(Adjacent)'라고 표현한다.



그래프 표현

- 두 방식의 차이
  - 메모리 측면에서 인접 행렬 방식은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비, 인접 리스트 방식은 연결된 정보만 저장하기 때문에 메모리를 효율적으로 사용
  - 인접 리스트 방식은 인접 행렬 방식에 비해 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느리다.
  - 특정한 노드와 연결된 모든 인접 노드를 순회해야 하는 경우, 인접 리스트 방식이 인접 행렬 방식에 비해 메모리 공간의 낭비가 적다.

1. 인접 행렬(Adjacency Matrix) : 2차원 배열로 그래프의 연결 관계를 표현하는 방식

   - 연결이 되어 있지 않은 노드끼리는 무한의 비용이라고 작성, 실제 코드에서는 논리적으로 정답이 될 수 없는 큰 값 중에서 999999999, 987654321 등의 값으로 초기화하는 경우가 많다.

   ``` python
   INF = 999999999 # 무한의 비용 선언
   
   # 2차원 리스트를 이용해 인접 행렬 표현
   graph = [
       [0, 7, 5],
       [7, 0, INF],
       [5, INF, 0]
   ]
   
   print(graph)
   
   # 결과
   [[0, 7, 5], [7, 0, 999999999], [5, 999999999, 0]]
   ```

   

2. 인접 리스트(Adjacency List) : 리스트로 그래프의 연결 관계를 표현하는 방식

   - 인접 리스트 방식에서는 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장한다.
   - 인접 리스트는 '연결 리스트'라는 자료구조를 이용해 구현, C++이나 자바와 같은 프로그래밍 언어네서는 별도로 연결 리스트 기능을 위한 표준 라이브러리를 제공, 파이썬은 기본 자료형인 리스트 자료형이 append()와 메소드를 제공하므로, 전통적인 프로그래밍 언어에서의 배열과 연결 리스트의 기능을 모두 기본으로 제공한다.
   - 파이썬으로 인접 리스트를 이용해 그래프를 표현하고자 할 때에도 단순히 2차원 리스트를 이용하면 된다는 점만 기억하자.

   ``` python
   # 행(Row)이 3개인 2차원 리스트로 인접 리스트 표현
   graph = [[] for _ in range(3)]
   
   # 노드 0에 연결된 노드 정보 저장(노드, 거리)
   graph[0].append((1, 7))
   graph[0].append((2, 5))
   
   # 노드 1에 연결된 노드 정보 저장(노드, 거리)
   graph[1].append((0, 7))
   
   # 노드 2에 연결된 노드 정보 저장(노드, 거리)
   graph[2].append((0, 5))
   
   print(graph)
   
   # 결과
   [[(1, 7), (2, 5)], [(0, 7)], [(0, 5)]]
   ```



#### 동작 과정

1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.(방문처리는 스택에 한 번 삽입되어 처리된 노드가 다시 삽입되지 않게 체크하는 것을 의미한다. 방문처리를 함으로써 각 노드를 한 번씩만 처리할 수 있다.)
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.



### BFS

> Breadth First Search, 너비 우선 탐색이라는 의미를 가진다. 쉽게 말해 가까운 노드부터 탐색하는 알고리즘이다.



- BFS 구현에서는 선입선출 방식인 큐 자료구조를 이용하는 것이 정석이다.
- 인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 작성하면 자연스럽게 먼저 들어온 것이 먼저 나가게 되어, 가까운 노드부터 탐색을 진행하게 된다.
- O(N)의 시간 소요, 일반적인 경우 실제 수행 시간은 dfs보다 좋은 편이다.



#### 동작 과정

1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.