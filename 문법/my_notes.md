# My_notes

## 기초

### 실수 입력받아 원하는 소수점까지 출력

``` python
a = float(input())

print('%.2f' % a)
```



### print() 속성 'sep=' 사용시 출력값 사이에 특정 문자 넣어 구분 가능

``` python
print(5, 9, sep=":")
```



### 원하는 길이만큼 출력(공백 0으로 채움)

``` python
y, m, d = map(int, input().split("."))

print('%04d' %y, '%02d' %m, '%02d' %d, sep=".")
```



### 2, 8, 16 진수

#### format 이용

``` python
a = format(int(input()), 'o') # 'b' 'o' 'x'

print(a)
```



#### print로 바로 출력

``` python
a = int(input())

print('%x' %a) # '%X' 대문자 사용시 대문자로 출력
```



#### 입력받은 진수와 다른 진수로 출력

``` python
a = input()

n = int(a,16) # a를 16진수로 반꾼 값을 10진수로 변경해서 저장

print("%o" % n) # n을 8진수로 출력
```



### ord() 문자의 아스키 코드 값을 반환(영문자 -> 아스키 10진수)

```python
a = input()

n = ord(a)

print(n)
```



### 10진수 -> 아스키 문자

``` python
a = input()

n = int(a)

c = chr(n)

print(c)
```



### 배열을 정렬한 후 조합을 실행하면 결과도 정렬이 된 상태로 나온다



### 2차원 배열에 값 입력 받기

``` python
a = [[0]*19 for i in range(19)]

for i in range(19):
    x = list(map(int, input().split()))
    for j in range(19):
        a[i][j] = x[j]
```



### 문자열 철자 하나씩 나누기

``` python
s = "hello"
print(s)

# 결과
 'h', 'e', 'l', 'l', 'o'
```



### list내에서 특정 문자의 인덱스 찾기

``` python
s = ['a', 'b']

idx = s.index('a')

# 실행시 idx = 0 반환
```



### join()

> 리스트에 특정 구분자를 추가하여 문자열로 변환함



```python
lst = ['a', 'b', 'c']
print( ",".join(lst) )
print(''.join(lst))

# 결과
a,b,c
abc
```





### 배열 인덱스 - 순환 / +순환

``` python
seat = [0, 1, 2, 3, 4]
idx = 1 # 현대 인덱스
idx -= 20 # 인덱스 -20만큼

num = len(seat)
if idx >= num:
    k = idx % num
    idx = k
elif idx < 0:
    k = (-idx) // num + 1
    idx += num * k
    if idx == num:
        idx = 0

print(idx)
```





### 크기가 4인 배열 +/- 순환

```python
# 왼쪽
	direction = (direction - 1) % 4
# 오른쪽
    direction = (direction + 1) % 4
```





### 2차원 리스트 슬라이싱

```python
data = [[0] * 3 for _ in range(4)]
n = 1
for i in range(4):
    for j in range(3):
        data[i][j] = n
        n += 1
        print(data[i][j], end=' ')
    print()
# 가로
print(data[2][1:])
# 세로
for i in range(1, 3):
    print(data[i][1:3])

# 결과
1 2 3 
4 5 6 
7 8 9
10 11 12
[8, 9]
[5, 6]
[8, 9]

# numpy 라이브러리가 사용 가능할 경우 더 쉽게 표현 가능
```







----



## Greedy

> 현재 상황에서 지금 당장 좋은 것만 고르는 방법
>
> 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.



### 특징

---

- 창의력을 요함, 특정한 문제를 만났을 때 단순히 현재 상황에서 가장 좋아 보이는 것만을 선택해도 문제를 풀 수 있는지를 파악할 수 있어야 한다.
- '가장 큰 순서대로', '가장 작은 순서대로'와 같은 기준을 알게 모르게 제시해준다.
- 그리디 알고리즘 문제는 정렬 알고리즘과 짝을 이뤄 자주 출제된다.
- 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 한다.



--------------



## Implementation

> 구현이란 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정



### 특징

---

- 프로그래밍 언어의 문법을 정확히 알고 있어야 하며 문제의 요구사항에 어긋나지 않는 답안 코드를 작성해야 한다.
- 구현 유형의 문제 : 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제
- 구현하기 어려운 문제
  - 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제
  - 특정 소수점 자리까지 출력해야 하는 문제
  - 문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에 넣어야 하는(파싱을 해야 하는) 문제
- 대체로 사소한 조건 설정이 많은 문제일수록 코드로 구현하기가 까다롭다.
- 완전 탐색, 시뮬레이션 유형을 모두 구현유형으로 묶어서 다룬다

### 완전탐색 / 시뮬레이션

----

> 두 유형 모두 구현이 핵심

- 완전 탐색 : 모든 경우의 수를 주저 없이 다 계산하는 해결 방법(확인(탐색)해야 할 전체 데이터 개수가 100만 개 이하일 때 완전탐색을 사용하면 적절하다.)
- 시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행



### 구현시 고려해야 할 메모리 제약 사항

---

#### C/C++에서 변수의 표현 범위

정수형 int 자료형을 주로 사용하며 이 자료형의 크기는 4바이트이다. 기본 int 자료형의 표현 범위는 -2147483648 ~ 2147438647 이다.

더 큰 수를 처리하기 위해서는 8바이트인 long long과 같은 자료형을 사용

훨씬 큰 수를 담을 변수를 만들려면 흔히 BigInteger 클래스를 구현하거나 이용해야 한다.

자바의 경우 BigInteger를 표준 라이브러리로 지원

| 정수형 종류        | 자료형의 크기 | 자료형의 범위                                          |
| :----------------- | :------------ | ------------------------------------------------------ |
| int                | 4바이트       | -2,147,483,648 ~ 2,147,438,647                         |
| long long          | 8바이트       | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |
| BigInteger(클래스) | 가변적        | 제한 없음                                              |



##### 파이썬에서 리스트 크기

리스트를 이용할 때에 코딩 테스트의 메모리 제한을 고려해야 한다.

int 자료형 데이터의 개수에 따른 메모리 사용량

| 데이터의 개수(리스트의 길이) | 메모리 사용량 |
| ---------------------------- | ------------- |
| 1,000                        | 약 4KB        |
| 1,000,000                    | 약 4MB        |
| 10,000,000                   | 약 40MB       |



#### 구현 문제에 접근하는 방법

---

- 보통 구현 유형의 문제는 사소한 입력 조건 등을 문제에서 명시해주며 문제의 길이가 꽤 긴 편이다.
- 고차원적인 사고력을 요구하는 문제는 나오지 않는 편이라 문법에 익숙하다면 쉽게 풀 수 있다.
- 문자열을 처리하거나 큰 수를 처리하는 문제가 출제되는 경우가 많다.



**Pypy3**

> 파이썬3의 문법을 그대로 지원하며, 대부분 파이썬3보다 실행 속도가 더 빠르다.
>
> 코딩테스트에서 Pypy3를 선택한다면 파이썬3와 동일한 코드를 제출해서 실행 시간을 줄일 수 있다.
>
> 반복문이 많을수록 Pypy3와 파이썬3의 속도가 차이 난다.





---





## DFS/BFS

> 그래프를 탐색하기 위한 대표적인 두 가지 알고리즘



### 탐색

- 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정을 의미
- 프로그래밍에서는 그래프, 트리 등의 자료구조 안에서 탐색을 하는 문제를 자주 다룬다.
- 대표적인 탐색 알고리즘 > DFS, BFS



### 자료구조

- 데이터를 표현하고 관리하고 처리하기 위한 구조를 의미
- 스택과 큐는 자료구조의 기초 개념으로 두 핵심적인 함수로 구성
  - 삽입(Push) : 데이터를 삽입
  - 삭제(Pop) : 데이터를 삭제
  - 오버플로(Overflow) : 특정한 자료구조가 수용할 수 있는 데이터의 크기를 이미 가득 찬 상태에서 삽입 연산을 수행할 때 발생
  - 언더플로(Underflow) : 특정한 자료구조에 데이터가 전혀 들어 있지 않은 상태에서 삭제 연산을 수행하면 발생



### 스택

- 스택(Stack)은 선입후출(First In Last Out) 구조 또는 후입선출(Last In First Out) 구조라고 한다.
- 파이썬에서 스택을 이용할 때에는 별도의 라이브러리를 사용할 필요가 없다.
- 기본 리스트에서 append()와 pop() 메서드를 이용하면 스택 자료구조와 동일하게 동작한다.



``` python
stack = []

stack.append(5)
stack.append(2)
stack.append(3)
stack.append(7)
stack.pop()
stack.append(1)
stack.append(4)
stack.pop()

print(stack) # 최하단 원소부터 출력
print(stack[::-1]) # 최상단 원소부터 출력

# 결과
[5, 2, 3, 1]
[1, 3, 2, 5]
```



### 큐

- 큐(Queue)는 선입선출(First In First Out) 구조라고 한다.
- 파이썬으로 큐를 구현할 때는 collections 모듈에서 제공하는 deque 자료구조를 활용
- deque는 스택과 큐의 장점을 모두 채택한 것인데 데이터를 넣고 빼는 속도가 리스트 자료형에 비해 효율적이며 queue 라이브러리를 이용하는 것보다 간단하다.
- 대부분의 코딩 테스트에서는 collections 모듈과 같은 기본 라이브러리 사용을 허용



``` python
from collections import deque

# 큐(Queue) 구현을 위해 deque 라이브러리 사용
queue = deque()

queue.append(5)
queue.append(2)
queue.append(3)
queue.append(7)
queue.popleft()
queue.append(1)
queue.append(4)
queue.popleft()

print(queue) # 먼저 들어온 순서대로 출력
queue.reverse() # 다음 출력을 위해 역순으로 바꾸기
print(queue) # 나중에 들어온 원소부터 출력

# 결과
deque([3, 7, 1, 4])
deque([4, 1, 7, 3])
```



### 재귀 함수

- 재귀함수란(Recursive Function)란 자기 자신을 다시 호출하는 함수를 의미

``` python
def recursive_function():
    print('재귀 함수 호출')
    recursive_function()
    
recursive_function()
```



#### 재귀 함수의 종료 조건

- 재귀 함수를 문제 풀이에서 사용할 때는 재귀 함수가 언제 끝날지, 종료 조건을 꼭 명시해야 한다.

``` python
def recursive_function(i):
    # 100번째 출력했을 때 종료되도록 종료 조건 명시
    if i == 100:
        return
    print(i, '번째 재귀 함수에서', i + 1, '번째 재귀 함수를 호출합니다')
    recursive_function(i + 1)
    print(i, '번째 재귀 함수를 종료')

recursive_function(1)
```

- 컴퓨터 내부에서 재귀 함수의 수행은 스택 자료구조를 이용한다. 함수를 계속 호출했을 때 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수 호출이 종료되기 때문이다.

``` python
# 재귀 함수를 이용한 대표적 예제 팩토리얼(Factorial) 두 가지 방식

# 반복적으로 구현한 n!
def factorial_iterative(n):
    result = 1
    # 1부터 n까지의 수를 차례대로 곱하기
    for i in range(1, n + 1):
        result *= i
    return result

# 재귀적으로 구현한 n!
def factorial_recursive(n): # n이 1 이하인 경우 1을 반환
    if n <= 1:
        return 1
    # n! = n * (n - 1)!를 그대로 코드로 작성하기
    return n * factorial_recursive(n - 1)

print('반복적으로 구현:', factorial_iterative(5))
print('재귀적으로 구현:', factorial_recursive(5))

# 결과
반복적으로 구현: 120
재귀적으로 구현: 120
```

- 반복문 대신 재귀 함수를 사용하면 코드가 더 간결하다. 이유는 재귀 함수가 수학의 점화식(재귀식)을 그대로 소스코드로 옮겼기 때문이다.
  - 수학에서 점화식은 특정한 함수를 자신보다 더 작은 변수에 대한 함수와의 관계로 표현한 것을 의미한다.
- 재귀 함수 내에서 특정 조건일 때 더 이상 재귀적으로 함수를 호출하지 않고 종료하도록 if문을 이용해 종료 조건을 구현해주어야 한다.



### DFS

>Depth-First Search, 깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.



#### 그래프

- 그래프는 노드(Node)와 간선(Edge)으로 표현되며 이때 노드를 정점(Vertex)이라고도 말한다.
- 그래프 탐색이란 하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말한다.
- 두 노드가 간선으로 연결되어 있다면 '두 노드는 인접하다(Adjacent)'라고 표현한다.



그래프 표현

- 두 방식의 차이
  - 메모리 측면에서 인접 행렬 방식은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비, 인접 리스트 방식은 연결된 정보만 저장하기 때문에 메모리를 효율적으로 사용
  - 인접 리스트 방식은 인접 행렬 방식에 비해 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느리다.
  - 특정한 노드와 연결된 모든 인접 노드를 순회해야 하는 경우, 인접 리스트 방식이 인접 행렬 방식에 비해 메모리 공간의 낭비가 적다.

1. 인접 행렬(Adjacency Matrix) : 2차원 배열로 그래프의 연결 관계를 표현하는 방식

   - 연결이 되어 있지 않은 노드끼리는 무한의 비용이라고 작성, 실제 코드에서는 논리적으로 정답이 될 수 없는 큰 값 중에서 999999999, 987654321 등의 값으로 초기화하는 경우가 많다.

   ``` python
   INF = 999999999 # 무한의 비용 선언
   
   # 2차원 리스트를 이용해 인접 행렬 표현
   graph = [
       [0, 7, 5],
       [7, 0, INF],
       [5, INF, 0]
   ]
   
   print(graph)
   
   # 결과
   [[0, 7, 5], [7, 0, 999999999], [5, 999999999, 0]]
   ```

   

2. 인접 리스트(Adjacency List) : 리스트로 그래프의 연결 관계를 표현하는 방식

   - 인접 리스트 방식에서는 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장한다.
   - 인접 리스트는 '연결 리스트'라는 자료구조를 이용해 구현, C++이나 자바와 같은 프로그래밍 언어네서는 별도로 연결 리스트 기능을 위한 표준 라이브러리를 제공, 파이썬은 기본 자료형인 리스트 자료형이 append()와 메소드를 제공하므로, 전통적인 프로그래밍 언어에서의 배열과 연결 리스트의 기능을 모두 기본으로 제공한다.
   - 파이썬으로 인접 리스트를 이용해 그래프를 표현하고자 할 때에도 단순히 2차원 리스트를 이용하면 된다는 점만 기억하자.

   ``` python
   # 행(Row)이 3개인 2차원 리스트로 인접 리스트 표현
   graph = [[] for _ in range(3)]
   
   # 노드 0에 연결된 노드 정보 저장(노드, 거리)
   graph[0].append((1, 7))
   graph[0].append((2, 5))
   
   # 노드 1에 연결된 노드 정보 저장(노드, 거리)
   graph[1].append((0, 7))
   
   # 노드 2에 연결된 노드 정보 저장(노드, 거리)
   graph[2].append((0, 5))
   
   print(graph)
   
   # 결과
   [[(1, 7), (2, 5)], [(0, 7)], [(0, 5)]]
   ```



#### 동작 과정

1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.(방문처리는 스택에 한 번 삽입되어 처리된 노드가 다시 삽입되지 않게 체크하는 것을 의미한다. 방문처리를 함으로써 각 노드를 한 번씩만 처리할 수 있다.)
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.



### BFS

> Breadth First Search, 너비 우선 탐색이라는 의미를 가진다. 쉽게 말해 가까운 노드부터 탐색하는 알고리즘이다.



- BFS 구현에서는 선입선출 방식인 큐 자료구조를 이용하는 것이 정석이다.
- 인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 작성하면 자연스럽게 먼저 들어온 것이 먼저 나가게 되어, 가까운 노드부터 탐색을 진행하게 된다.
- O(N)의 시간 소요, 일반적인 경우 실제 수행 시간은 dfs보다 좋은 편이다.



#### 동작 과정

1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.





---





## Sorting

> 연속된 데이터를 기준에 따라서 정렬하기 위한 알고리즘
>
> 정렬이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것
>
> 정렬 알고리즘은 이진 탐색의 전처리 과정



### 선택 정렬

- 데이터가 무작위로 여러 개 있을 때, 이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복
- 이 방법은 매번 가장 작은 것을 선택한다는 의미에서 선택 정렬(Selection Sort) 알고리즘이라 한다.

``` python
# 선택 정렬 소스코드

array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    min_index = i # 가장 작은 원소의 인덱스
    for j in range(i + 1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array[min_index], array[i] # 스와프

print(array)
```

``` python
# 파이썬 Swap 소스코드

# 0 인덱스와 1 인덱스의 원소 교체하기
array = [3, 5]
array[0], array[1] = array[1], array[0]

print(array)
```

``` c
// C언어로 구현한 스와프 예제

int a = 3;
int b = 5;

// 스와프
int temp = a;
a = b;
b = temp;
```



- 선택 정렬의 시간 복잡도 : O(N <sup>2</sup>)



### 삽입 정렬

- 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입
- 선택 정렬에 비해 실행 시간 측면에서 더 효율적
- 필요할 때만 위치를 바꾸므로 '데이터가 거의 정렬 되어 있을 때' 훨씬 효율적이다.
- 특정한 데이터를 적절한 위치에 '삽입'한다는 의미에서 삽입 정렬(Insertion Sort)라 한다.
- 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.
- 삽입 정렬은 두 번째 데이터부터 시작한다. 첫 번째 데이터는 그 자체로 정렬되어 있다고 판단하기 때문이다.
- 정렬이 이루어진 원소는 항상 오름차순을 유지하고 있다. 이 특징 때문에 삽입 정렬에서는 특정한 데이터가 삽입될 위치를 선정할 때, 삽입될 데이터보다 작은 데이터를 만나면 그 위치에서 멈추면 된다.

``` python
# 삽입 정렬 소스코드

array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)):
    for j in range(i, 0, -1): # 인덱스 i부터 1까지 감소하며 반복
        if array[j] < array[j - 1]: # 한 칸씩 왼쪽으로 이동
            array[j], array[j - 1] = array[j - 1], array[j]
        else: # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
            break

print(array)
```



- 삽입 정렬의 시작 복잡도 : O(N <sup>2</sup>)



**range의 세 번째 매개 변수**

- range(start, end, step), step에 -1이 들어가면 start 인덱스부터 시작해서 end + 1 인덱스까지 1씩 감소한다.



### 퀵 정렬

- 정렬 알고리즘 중에 가장 많이 사용되는 알고리즘
- 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾼다
- 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.
- 퀵 정렬에서는 피벗(Pivot)이 사용된다. 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 '기준'을 바로 피벗이라고 표현한다.
- 퀵 정렬을 수행하기 전에는 피벗을 어떻게 설정할 것인지 미리 명시해야 한다.
- 가장 대표적인 분할 방식인 호어 분할(Hoare Partition) 방식을 기준으로 퀵 정렬 수행
- 호어 분할 방식에서는 **리스트에서 첫 번째 데이터**를 피벗으로 정한다.



순서

1. 피벗을 설정한 뒤 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다.
2. 큰 데이터와 작은 데이터의 위치를 서로 교환해준다.
3. 단, 왼쪽에서부터 찾는 값과 오른쪽에서부터 찾는 값의 위치가 서로 엇갈린 경우에는 '작은 데이터'와 '피벗'의 위치를 서로 변견한다.
4. 이 과정을 반복하면 피벗에 대하여 정렬이 수행된다.
5. 처음 피벗을 기준으로 왼쪽에는 피벗보다 작은 데이터, 오른쪽에는 피벗보다 큰 데이터가 위치하게 된다. 이작업을 분할(Divide) 혹은 파티션(Partition)이라 한다.
6. 이 상태에서 동일한 방식으로 왼쪽 리스트와 오른쪽 리스트를 개별적으로 정렬을 수행하면 전체 리스트에 대하여 정렬이 이루어 진다.



- 퀵 정렬은 재귀 함수 형태로 작성하면 구현이 간결해진다.
- 퀵 정렬이 끝나는 조건은 바로 현재 리스트의 데이터 개수가 1개인 경우이다. 리스트의 원소가 1개라면, 이미 정렬이 되어 있다고 간주할 수 있으며 분할이 불가능하다.

``` python
# 퀵 정렬 소스코드

array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end):
    if start >= end: # 원소가 1개인 경우 종료
        return
    pivot = start # 피벗은 첫 번째 원소
    left = start + 1
    right = end
    while left <= right:
        # 피벗보다 큰 데이터를 찾을 때까지 반복
        while left <= end and array[left] <= array[pivot]:
            left += 1
        # 피벗보다 작은 데이터를 찾을 때까지 반복
        while right > start and array[right] >= array[pivot]:
            right -= 1
        if left > right: # 엇갈렸다면 작은 데이터와 피벗을 교체
            array[right], array[pivot] = array[pivot], array[right]
        else: # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
            array[left], array[right] = array[right], array[left]
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quick_sort(array, start, right - 1)
    quick_sort(array, right + 1, end)

quick_sort(array, 0, len(array) - 1)
print(array)
```

``` python
# 파이썬의 장점을 살린 퀵 정렬 소스코드

array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array):
    # 리스트가 하나 이하의 원소만을 담고 있다면 종료
    if len(array) <= 1:
        return array
    
    pivot = array[0] # 피벗은 첫 번째 원소
    tail = array[1:] # 피벗을 제외한 리스트

    left_side = [x for x in tail if x <= pivot] # 분할된 왼쪽 부분
    right_side = [x for x in tail if x > pivot] # 분할된 오른쪽 부분

    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬을 수행하고, 전체 리스트를 반환
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)

print(quick_sort(array))
```



- 퀵 정렬의 시간 복잡도 : O(NlogN)



### 계수 정렬

- 계수 정렬(Count Sort) 알고리즘은 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다.
- 모든 데이터가 양의 정수인 상황을 가정시 데이터의 개수가 N, 데이터 중 최댓값이 K일 때, 계수 정렬은 최악의 경우에도 수행 시간 O(N + K)를 보장한다.
- 계수 정렬은 '데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때'만 사용할 수 있다.
- 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적이다.
- 이유는 계수 정렬을 이용할 때는 '모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언'해야 하기 때문이다.
- 예를 들어 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000이라면 총 1,000,001개의 데이터가 들어갈 수 있는 리스트를 초기화해야 한다. 0부터 1,000,000까지는 총 1,000,001개의 수가 존재하기 때문이다.
- 계수 정렬은 앞서 다루었던 정렬 알고리즘처럼 직접 데이터의 값을 비교한 뒤에 위치를 변경하며 정렬하는 방식(비교 기반의 정렬 알고리즘)이 아니다.
- 계수 정렬은 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는다는 특징이 있다.

``` python
# 계수 정렬 소스코드

# 모든 원소의 값이 0보다 크거나 같다고 가정
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
# 모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1 # 각 데이터에 해당하는 인덱스의 값 증가

for i in range(len(count)): # 리스트에 기록된 정렬 정보 확인
    for j in range(count[i]):
        print(i, end=' ') # 띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력
```



- 계수 정렬의 시간 복잡도 : 모든 데이터가 양의 정수인 상황을 가정시 데이터의 개수가 N, 데이터 중 최댓값이 K일 때, O(N + K)
- 데이터의 범위만 한정되어 있다면 현존하는 정렬 알고리즘 중에서 기수 정렬(Radix Sort)과 더불어 가장 빠르다고 볼 수 있다.
- 계수 정렬의 공간 복잡도
  - 계수 정렬은 상황에 따라서 심각한 비효율성을 초래할 수 있다.
  - 예를 들어 데이터가 0과 999,999 단 2개만 존재할 때, 이럴 때에도 리스크의 크기가 100만 개가 되도록 선언해야 한다.
  - 따라서 항상 사용할 수 있는 정렬 알고리즘은 아니며, 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합하다.



### 파이썬의 정렬 라이브러리

- 파이썬은 기본 정렬 라이브러리인 sorted() 함수를 제공한다.
- sorted()는 퀵 정렬과 동작 방식이 비슷한 병합 정렬을 기반으로 만들어졌는데, 병합 정렬은 일반적으로 퀵 정렬보다 느리지만 최악의 경우에도 시간 복잡도 O(NlogN)을 보장한다는 특징이 있다.
- sorted() 함수는 리스트, 딕셔너리 자료형 등을 입력받아서 정렬된 결과를 출력한다. 반환 결과는 리스트 자료형이다.
- 리스트 변수가 하나 있을 때 내부 원소를 바로 정렬할 때는 리스트 객체의 내장 함수인 sort()를 이용한다. 이를 이용하면 별도의 정렬된 리스트가 반횐되지 않고 내부 원소가 바로 정렬된다.
- sorted()나 sort()를 이용할 때 key 매개변수를 입력으로 받을 수 있다. key 값으로는 하나의 함수가 들어가야 하며 이는 정렬 기준이 된다.

``` python
array = [('바나나', 2), ('사과', 5), ('당근', 3)]

def setting(data):
    return data[1]

result = sorted(array, key = setting)
print(result)
```



- 정렬 라이브러리의 시간 복잡도 : 최악의 경우에도 시간 복잡도 O(NlogN)을 보장한다.
- 문제에서 별도의 요구가 없다면 단순히 정렬해야 하는 상황에서는 기본 정렬 라이브러리를 사용하고, 데이터의 범위가 한정되어 있으면 계수 정렬을 사용



**정렬 알고리즘이 사용되는 3가지 문제 유형**

1. 정렬 라이브러리로 풀 수 있는 문제 : 단순히 정렬 기법을 알고 있는지 물어보는 문제로 기본 정렬 라이브러리의 사용 방법을 숙지하고 있으면 어렵지 핞게 풀 수 있다.
2. 정렬 알고리즘의 원리에 대해서 물어보는 문제 : 선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리를 알고 있어야 문제를 풀 수 있다.
3. 더 빠른 정렬이 필요한 문제 : 퀵 정렬 기반의 정렬 기법으로는 풀 수 없으며 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나 문제에서 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있다.





---



## Binary Search

> 탐색 범위를 반으로 좁혀가며 빠르게 탐색하는 알고리즘



### 순차 탐색

- 순차 탐색(Sequential Search)이란 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법이다.
- 보통 정렬되지 않은 리스트에서 데이터를 찾아야 할 때 사용한다.
- 데이터가 아무리 많아도 시간만 충분하다면 항상 원하는 원소(데이터)를 찾을 수 있다.
- 리스트에 특정 값의 원소가 있는지 체크할 때, 리스트 자료형에서 특정한 값을 가지는 원소의 개수를 세는 count() 메서드를 이용할 때도 내부에서는 순차 탐색이 수행된다.
- 순차 탐색은 최악의 경우 시간 복잡도가 O(N)이다.



### 이진 탐색 : 반으로 쪼개면서 탐색하기

- 이진 탐색은 배열 내부의 데이터가 정렬되어 있어야만 사용할 수 있는 알고리즘이다.
- 데이터가 무작위일 때는 사용할 수 없지만, 이미 정렬되어 있다면 매우 빠르게 데이터를 찾을 수 있다.
- 이진 탐색은 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 특징이 있다.
- 위치를 나타내는 변수 3개를 사용하는데 탐색하고자 하는 범위의 **시작점**, **끝점**, **중간점**이다.
- 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를 찾는 게 이진 탐색 과정이다.
- 시간 복잡도 : O(logN), 절반씩 데이터를 줄어들도록 만든다는 점은 퀵 정렬과 공통점이 있다. 



### 트리 자료구조

- 데이터베이스는 내부적으로 대용량 데이터 처리에 적합한 트리(Tree) 자료구조를 이용하여 항상 데이터가 정렬되어 있다.
- 데이터베이스에서의 탐색은 이진 탐색과는 조금 다르지만, 이진 탐색과 유사한 방법을 이용해 탐색을 항상 빠르게 수행하도록 설계되어 있어서 데이터가 많아도 탐색하는 속도가 빠르다.
- 트리 자료구조는 노드와 노드의 연결로 표현하며 여기에서 노드는 정보의 단위로서 어떠한 정보를 가지고 있는 개체로 이해할 수 있다.
- 트리 자료구조는 그래프 자료구조의 일종으로 데이터베이스 시스템이나 파일 시스템과 같은 곳에서 많은 양의 데이터를 관리하기 위한 목적으로 사용한다.



트리 자료구조 특징

- 트리는 부모 노드와 자식 노드의 관계로 표현된다.
- 트리의 최상단 노드를 루트 노드라고 한다.
- 트리의 최하단 노드를 단말 노드라고 한다.
- 트리에서 일부를 떼어내도 트리 구조이며 이를 서브 트리라 한다.
- 트리는 파일 시스템과 같이 계층적이고 정렬된 데이터를 다루기에 적합하다.



### 이진 탐색 트리

- 트리 자료구조 중에서 가장 간단한 형태가 이진 탐색 트리이다.
- 이진 탐색 트리란 이진 탐색이 동작할 수 있도록 고안된, 효율적인 탐색이 가능한 자료구조이다.



이진 탐색 트리 특징

- 부모 노드보다 왼쪽 자식 노드가 작다.
- 부모 노드보다 오른쪽 자식 노드가 크다.
- 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드가 성립해야 이진 탐색 트리라 할 수 있다.



빠르게 입력받기

- 이진 탐색 문제는 입력 데이터가 많거나, 탐색 범위가 매우 넓은 편이다. 데이터의 개수가 1,000만 개를 넘어가거나 탐색 범위의 크기가 1,000억 이상이라면 이진 탐색 알고리즘을 의심해보자.
- 입력 데이터의 개수가 많은 문제에 input() 함수를 사용하면 동작 속도가 느려서 시간 초과로 오답 판정을 받을 수 있다.
- 입력 데이터가 많은 문제는 sys 라이브러리의 readline() 함수를 이용하면 시간 초과를 피할 수 있다.



```python
# 한 줄 입력받아 출력하는 소스코드

import sys

input_data = sys.stdin.readline().rstrip()

print(input_data)
```



- sys 라이브러리를 사용할 때는 한 줄 입력받고 나서 rstrip() 함수를 꼭 호출해야 한다.
- 소스코드에 readlint()으로 입력하면 입력 후 엔터가 줄 바꿈 기호로 입력되는데, 이 공백 문자를 제거하려면 rstrip() 함수를 사용해야 한다.



---



## Dynamic Programming

> 한 번 계산한 문제는 다시 계산하지 않도록 하는 알고리즘
>
> 다이나믹 프로그래밍기법, 동적 계획법



대표적인 예시 : 피보나치 수열

프로그래밍에서는 수열을 **배열**이나 **리스트**로 표현할 수 있다.

``` python
# 피보나치 함수 소스코드

def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)

print(fibo(4))
```



사용 조건

- 큰 문제를 작은 문제로 나눌 수 있다.
- 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.



### 메모이제이션(Memoization) 기법

- 다이나믹 프로그래밍을 구현하는 방법 중 한 종류
- 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법
- 메모이제이션은 값을 저장하는 방법이므로 캐싱(Caching)이라고도 한다.
- 한 번 구한 정보를 리스트에 저장
- 재귀적으로 수행하다가 같은 정보가 필요할 때는 이미 구한 정답을 그대로 리스트에서 가져온다.
- 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법

``` python
# 피보나치 수열 소스코드(재귀적)

d = [0] * 100

def fibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]

print(fibo(99))
```



- 재귀 함수를 사용하면 컴퓨터 시스템에서는 함수를 다시 호출했을 때 메모리 상에 적재되는 일련의 과정을 따라야 하므로 오버헤드가 발생할 수 있다.
- 반복문을 사용하여 오버헤드를 줄일 수 있다. 일반적으로 반복문을 이용한 다이나믹 프로그래밍이 더 성능이 좋기 때문



``` python
# 호출되는 함수 확인

d = [0] * 100

def fibo(x):
    print('f(' + str(x) + ')', end=' ')
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]

fibo(6)

# 결과

f(6) f(5) f(4) f(3) f(2) f(1) f(2) f(3) f(4)
```



- 이처럼 재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을, 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 **탑다운(Top-Down)** 방식이라고 한다.
- 반면에 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 **보텀업(Bottom-Up)** 방식이라고 한다.



``` python
# 피보나치 수열 소스코드(반복적)

d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]

print(d[n])
```



- 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이다.
- 보텀업 방식에서 사용되는 결과 저장용 리스트는 'DP 테이블'이라고 부르며, 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다.
- 메모이제이션은 때에 따라서 다른 자료형, 예를 들어 사전(dict) 자료형을 이용할 수도 있다. 연속적이지 않은 경우에 유용
- 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있어 recursion depth(재귀 함수 깊이)와 관련된 오류가 발생할 수 있다.
- 이 경우 sys 라이브러리에 포함되어 있는 setrecursionlimit() 함수를 호출하여 재귀 제한을 완화할 수 있다.



---



## Shortest Path

> 최단 경로, 특정 지점까지 가장 빠르게 도달하는 방법을 찾는 알고리즘
>
> 가장 짧은 경로를 찾는 알고리즘, '길 찾기' 문제라고도 불린다.



**특징**

- 최단 경로 알고리즘은 보통 그래프로 표현, 각 지점은 그래프에서 '노드'로 표현되고, 지점 간 연결된 도로는 그래프에서 '간선'으로 표현된다.
- 코딩 테스트에서는 최단 경로를 모두 출력하는 문제보다는 단순히 최단 거리를 출력하도록 요구하는 문제가 많이 출제된다.
- 다익스트라 최단 경로 알고리즘, 플로이드 워셜, 벨만 포드 알고리즘 등이 있다.
- 그리디 알고리즘과 다이나믹 프로그래밍 알고리즘이 최단 경로 알고리즘에 그대로 적용된다.



### 다익스트라 최단 경로 알고리즘

- 다익스트라(Dijkstra) 최단 경로 알고리즘은 그래프에서 여러 개의 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘이다.
- '음의 간선'이 없을 때 정상적으로 동작한다. 음의 간선이란 0보다 작은 값을 가지는 간선을 의미한다.
- 다익스트라 최단 경로 알고리즘은 기본적으로 그리디 알고리즘으로 분류된다. 매번 '가장 비용이 적은 노드'를 선택해서 임의의 과정을 반복하기 때문이다.



**원리**

1. 출발 노드를 설정한다.
2. 최단 거리 테이블을 초기화한다.
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
5. 위 과정에서 3과 4번을 반복한다.



- 최단 경로를 구하는 과정에서 '각 노드에 대한 현재까지의 최단 거리' 정보를 항상 1차원 리스트에 저장하며 리스트를 계속 갱신한다는 특징이 있다.
- 매번 현재 처리하고 있는 노드를 기준으로 주변 간선을 확인한다.
- 다익스트라 알고리즘이 진행되면서 한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해할 수 있다.



**구현하는 방법 2가지**

1. 구현하기 쉽지만 느리게 동작하는 코드
2. 구현하기에 조금 더 까다롭지만 빠르게 동작하는 코드



#### 방법 1. 간단한 다익스트라 알고리즘

- 간단한 다익스트라 알고리즘은 O(V<sup>2</sup>)의 시간 복잡도를 가진다. 여기서 V는 노드의 개수를 의미한다.
- 처음에 각 노드에 대한 최단 거리를 담는 1차원 리스트를 선언한다.
- 이후에 단계마다 '방문하지 않는 노드 중에서 최단 거리가 가장 짧은 노드를 선택'하기 위해 매 단계마다 1차원 리스트의 모든 원소를 확인(순차 탐색)한다.
- 모든 리스트는 (노드의 개수 + 1)의 크기로 할당하여, 노드의 번호를 인덱스로 하여 바로 리스트에 접근할 수 있도록 했다.

```python
# 간단한 다익스트라 알고리즘 소스코드

import sys

input = sys.stdin.readline
INF = int(1e9)

# 노드의 개수, 간선의 개수 입력
n, m = map(int, input().split())
# 시작 노드 입력
start = int(input())
graph = [[] for i in range(n + 1)]
visited = [False] * (n + 1)
distance = [INF] * (n + 1)

for _ in range(m):
    # a번 노드에서 b번 노드로 가능 비용 c
    a, b, c = map(int, input().split())
    graph[a].append((b, c))

def get_smallest_node():
    min_value = INF
    index = 0
    for i in range(1, n + 1):
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            index = i
    return index

def dijkstra(start):
    distance[start] = 0
    visited[start] = True
    for j in graph[start]:
        distance[j[0]] = j[1]
    for i in range(n - 1):
        now = get_smallest_node()
        visited[now] = True
        for j in graph[now]:
            cost = distance[now] + j[1]
            if cost < distance[j[0]]:
                distance[j[0]] = cost

dijkstra(start)

for i in range(1, n + 1):
    if distance[i] == INF:
        print("INFINITY")
    else:
        print(distance[i])
        
# 입력
6 11
1
1 2 2
1 3 5
1 4 1
2 3 3
2 4 2
3 2 3
3 6 5
4 3 3
4 5 1
5 3 1
5 6 2

# 출력
0
2
3
1
2
4
```



**간단한 다익스트라 알고리즘의 시간 복잡도**

- 앞서 시간 복잡도는 O(V<sup>2</sup>)이라고 했다. 왜냐하면 총 O(V)번에 걸쳐서 최단 거리가 가장 짧은 노드를 매번 선형 탐색해야 하고, 현재 노드와 연결된 노드를 매번 일일히 확인하기 때문이다.
- 따라서 코딩 테스트의 최단 경로 문제에서 전체 노드의 개수가 5,000개 이하라면 일반적으로 이 코드로 문제를 풀 수 있을 것이다. 하지만 노드의 개수가 10,000개를 넘어가는 문제라면 이 코드로는 문제를 해결하기 어렵다.



#### 방법 2. 개선된 다익스트라 알고리즘

- 최악의 경우에도 시간 복잡도 O(ElogV)를 보장하여 해결할 수 있다. V는 노드의 개수, E는 간선의 개수를 의미한다.
- 최단 거리가 가장 짧은 노드를 단순히 선형적으로 찾는 것이 아니라 더욱더 빠르게 찾으면 시간 복잡도를 줄일 수 있을 것이다. > 힙(Heap) 자료구조를 사용한다.
- 힙 자료구조를 이용하면 특정 노드까지의 최단 거리에 대한 정보를 힙에 담아서 처리하므로 출발 노드로부터 가장 거리가 짧은 노드를 더욱 빠르게 찾을 수 있다.



##### 힙 설명

- 힙 자료구조는 우선순위 큐(Priority Queue)를 구현하기 위해 사용하는 자료구조 중 하나다.
- **우선순위 큐**는 우선순위가 가장 높은 데이터를 가장 먼저 삭제한다는 점이 특징이다.
- 우선순위 큐는 데이터를 우선순위에 따라 처리하고 싶을 때 사용한다.
- 대부분의 프로그래밍 언어에서는 우선순위 큐 라이브러리를 지원하기 때문에 직접 구현할 일은 없다.
- 파이썬에서는 우선순위 큐가 필요할 때 PriorityQueue 혹은 heapq를 사용할 수 있다. 다만, PriorityQueue 보다는 일반적으로 heapq가 더 빠르게 동작하기 때문에 heapq를 권장한다.
- 우선순위 값을 표현할 때는 일반적으로 정수형 자료형의 변수가 사용된다.
- 대부분의 프로그래밍 언어에서는 우선순위 큐 라이브러리에 데이터의 묶음을 넣으면, 첫 번쨰 원소를 기준으로 우선순위를 설정한다. 데이터가 (가치, 물건)으로 구성된다면 '가치' 값이 우선순위 값
- 우선순위 큐를 구현할 때는 내부적으로 최소 힙(Min Heap) 혹은 최대 힙(Max Heap)을 이용한다.
- 최소힙을 이용하는 경우 '값이 낮은 데이터가 먼저 삭제'되며, 최대 힙을 이용하는 경우 '값이 큰 데이터가 먼저 삭제'된다.
- N개의 데이터에 대한 시간 복잡도는 삽입할 때 O(logN), 삭제할 때에도 O(logN)이다. 따라서 전체 시간 복잡도는 O(NlogN)이 될 것이다.
- 우선순위 큐를 이용해서 시작 노드로부터 '거리'가 짧은 노드 순서대로 큐에서 나올 수 있도록 다익스트라 알고리즘을 작성하면 된다.
- 현재 가장 가까운 노드를 저장하기 위한 목적으로만 우선순위 큐를 추가로 이용한다고 보면 된다.

``` python
# 개선된 다익스트라 알고리즘 소스코드

import heapq
import sys

input = sys.stdin.readline
INF = int(1e9)

n, m = map(int, input().split())
start = int(input())
graph = [[] for i in range((n + 1))]
distance = [INF] * (n + 1)

for _ in range(m):
    a, b, c = map(int, input().split())
    graph[a].append((b, c))

def dijkstra(start):
    q = []
    heapq.heappush(q, (0, start))
    distance[start] = 0
    while q:
        dist, now = heapq.heappop(q)
        if distance[now] < dist:
            continue
        for i in graph[now]:
            cost = dist + i[1]
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))

dijkstra(start)

for i in range(1, n + 1):
    if distance[i] == INF:
        print("INFINITY")
    else:
        print(distance[i])
```



**개선된 다익스트라 알고리즘의 시간 복잡도**

- 개선된 다익스트라 알고리즘은 시간 복잡도가 O(ElogV)로 훨씬 빠르다.



#### 플로이드 워셜 알고리즘

- 플로이드 워셜 알고리즘(Floyd-Warshall Algorithm)은 '모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우'에 사용할 수 있는 알고리즘이다.
- 플로이드 워셜 알고리즘 또한 단계마다 '거쳐 가는 노드'를 기준으로 알고리즘을 수행한다. 하지만 매번 방문하지 않은 노드 중에서 최단 거리를 갖는 노드를 찾을 필요가 없다는 점이 다르다.
- 플로이드 워셜 알고리즘의 총시간 복잡도는 O(N<sup>3</sup>)이다.
- 다익스트라 알고리즘은 출발 노드가 1개이므로 다른 모든 노드까지의 최단 거리를 저장하기 위해서 1차원 리스트를 이용했다. 반면에 플로이드 워셜 알고리즘은 2차원 리스트에 '최단 거리' 정보를 저장한다는 특징이 있다. 모든 노드에 대하여 다른 모든 노드로 가는 최단 거리 정보를 담아야 하기 때문이다.
- 플로이드 워셜 알고리즘은 다이나믹 프로그래밍이라는 특징이 있다.
- D<sub>ab</sub> = min(D<sub>ab</sub>, D<sub>ak</sub> + D<sub>kb</sub>) A에서 B로 가는 최소 비용과 A에서 K를 거쳐 B로 가는 비용을 비교하여 더 작은 값으로 갱신

```python
# 플로이드 워셜 알고리즘 소스코드

INF = int(1e9)

# 노드 개수, 간선 개수
n = int(input())
m = int(input())
graph = [[INF] * (n + 1) for _ in range(n + 1)]

for a in range(1, n + 1):
    for b in range(1, n + 1):
        if a == b:
            graph[a][b] = 0

for _ in range(m):
    a, b, c = map(int, input().split())
    graph[a][b] = c

for k in range(1, n + 1):
    for a in range(1, n + 1):
        for b in range(1, n + 1):
            graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])

for a in range(1, n + 1):
    for b in range(1, n + 1):
        if graph[a][b] == INF:
            print("INFINITY", end=" ")
        else:
            print(graph[a][b], end=" ")
    print()

# 입력
4
7
1 2 4
1 4 6
2 1 3
2 3 7
3 1 5
3 4 4
4 3 2

# 출력
0 4 8 6 
3 0 7 9
5 9 0 4
7 11 2 0
```



---



## Graph

> 코딩 테스트에서 자주 등장하는 기타 그래프 이론



**앞서 배운 내용**

- 그래프(Graph)란 노드(Node)와 노드 사이에 연결된 간선(Edge)의 정보를 가지고 있는 자료구조를 의미한다. '서로 다른 개체(혹은 객체)가 연결되어 있다'는 이야기를 들으면 그래프 알고리즘을 떠올려야 한다.

- 트리(Tree) 자료 구조는 부모에서 자식으로 내려오는 계층적인 모델에 속한다.

- 그래프의 구현 방법
  - 인접 행렬(Adjacency Matrix) : 2차원 배열을 사용하는 방식

  - 인전 리스트(Adjacency List) : 리스트를 사용하는 방식



### 서로소 집합

- 수학에서 서로소 집합(Disjoint Sets)이란 공통 원소가 없는 두 집합을 의미한다.
- 서로서 집합 자료구조란 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조라고 할 수 있다.
- 서로소 집합 자료구조는 union과 find 2개의 연산으로 조작할 수 있다.
  - union(합집합) 연산은 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
  - find(찾기) 연산은 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산
- 서로소 집합 자료구조는 union-find 자료구조라고 불리기도 한다.



**서로소 집합 자료구조**

- 서로소 집합 자료구조를 구현할 때는 트리 자료구조를 이용하여 집합을 표현하는데, 서로소 집합 정보(합집합 연산)가 주어졌을 때 트리 자료구조를 이용해서 집합을 표현하는 서로소 집합 계산 알고리즘은 다음과 같다.
  - 1. union 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인한다.
       1. A와 B의 루트 노드 A', B'를 각각 찾는다.
       2. A'를 B'의 부모 노드로 설정한다(B'가 A'를 가리키도록 한다.)
    2. 모든 union 연산을 처리할 때까지 1번 과정을 반복한다.
  - 실제로 구현할 때는 A'와 B' 중에서 더 번호가 작은 원소가 부모 노드가 되도록 구현하는 경우가 많다.
  - 루트를 찾기 위해서는 재귀적으로 부모를 거슬러 올라가야 한다.

```python
# 기본적인 서로소 집합 알고리즘 소스코드

# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    if parent[x] != x:
        return find_parent(parent, parent[x])
    return x

# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

# 노드의 개수와 간선(union 연산)의 개수 입력받기
v, e = map(int, input().split())
parent = [0] * (v + 1)

# 부모 테이블에서 부모를 자기 자신으로 초기화
for i in range(1, v + 1):
    parent[i] = i

# union 연산을 각각 수행
for i in range(e):
    a, b = map(int, input().split())
    union_parent(parent, a, b)

# 각 원소가 속한 집합 출력
print('각 원소가 속한 집합: ', end='')
for i in range(1, v + 1):
    print(find_parent(parent, i), end=' ')

print()

# 부모 테이블 내용 출력
print('부모 테이블: ', end='')
for i in range(1, v + 1):
    print(parent[i], end=' ')

# 입력
6 4
1 4
2 3
2 4
5 6
# 출력
각 원소가 속한 집합: 1 1 1 1 5 5 
부모 테이블: 1 1 2 1 5 5
```

- 이렇게 구현하면 답을 구할 수는 잇지만, find 함수가 비효율적으로 동작한다. 최악의 경우 find 함수가 모든 노드를 다 확인해 시간 복잡도가 O(V)이다.
- 노드 개수가 V개이고 find 혹은 union 연산의 개수가 M개일 때, 전체 시간 복잡도는 O(VM)이 되어 비효율적이다.
- 이는 경로 압축(Path Compression) 기법을 적용하면 시간 복잡도를 개선시킬 수 있다. 경로 압축은 find 함수를 재귀적으로 호출한 뒤에 부모 테이블값을 갱신하는 기법이다.

```python
# 경로 압축 기법 소스코드
def find_parent2(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]
```

- 루트 노드에 더욱 빠르게 접근할 수 있다는 점에서 기존의 알고리즘과 비교했을 때 시간 복잡도가 개선된다.

```python
# 개선된 서로소 집합 알고리즘 소스코드

# 경로 압축 기법 소스코드
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

v, e = map(int, input().split())
parent = [0] * (v + 1)

for i in range(1, v + 1):
    parent[i] = i

for i in range(e):
    a, b = map(int, input().split())
    union_parent(parent, a, b)

print('각 원소가 속한 집합: ', end='')
for i in range(1, v + 1):
    print(find_parent(parent, i), end=' ')

print()

print('부모 테이블: ', end='')
for i in range(1, v + 1):
    print(parent[i], end=' ')

# 입력
6 4
1 4
2 3
2 4
5 6
# 출력
각 원소가 속한 집합: 1 1 1 1 5 5 
부모 테이블: 1 1 1 1 5 5
```



- 서로소 집합 알고리즘의 시간 복잡도
  - 경로 압축 방법만을 이용할 경우 노드의 개수 V개, 최대 V - 1개의 union 연산과 M개의 find 연산이 가능할 때 경로 압축 방법을 적용한 시간 복잡도는 O(V + M(1 + log<sub>2-M/V</sub>V)) 이다.



**서로소 집합을 이요한 사이클 판별**

- 서로소 집합은 무방향 그래프 내에서의 사이클을 판별할 때 사용할 수 있다는 특징이 있다. 참고로 방향 그래프에서의 사이클 여부는 DFS를 이용하여 판별할 수 있다.
- union 연산은 그래프에서의 간선으로 표현될 수 있다고 했다. 따라서 간선을 하나씩 확인하면서 두 노드가 포함되어 있는 집합을 합치는 과정을 반복하는 것만으로도 사이클을 판별할 수 있다.
  - 1. 각 간선을 확인하며 두 노드의 루트 노드를 확인한다.
       1. 루트 노드가 서로 다르다면 두 노드에 대하여 union 연산을 수행한다.
       2. 루트 노드가 서로 같다면 사이클(Cycle)이 발생한 것이다.
    2. 그래프에 포함되어 있는 모든 간선에 대하여 1번 과정을 반복한다.

- 이러한 사이클 판별 알고리즘은 그래프에 포함되어 있는 간선의 개수가 E개일 때 모든 간선을 하나씩 확인하며, 매 간선에 대하여 union 및 find 함수를 호출하는 방식으로 동작한다.

```python
# 서로소 집합을 활용한 사이클 판별 소스코드

def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

v, e = map(int, input().split())
parent = [0] * (v + 1)

for i in range(1, v + 1):
    parent[i] = i

cycle = False

for i in range(e):
    a, b = map(int, input().split())
    if find_parent(parent, a) == find_parent(parent, b):
        cycle = True
        break
    else:
        union_parent(parent, a, b)

if cycle:
    print("사이클이 발생했습니다.")
else:
    print("사이클이 발생하지 않았습니다.")
    

# 입력
3 3
1 2
1 3
2 3
# 출력
사이클이 발생했습니다.
```





### 신장 트리

- 신장 트리(Spanning Tree)란 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 의미한다.
- 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다는 조건은 트리의 성립 조건이기도 하다.



**크루스칼 알고리즘**

- 신장 트리 중에서 최소 비용으로 만들 수 있는 신장 트리를 찾는 알고리즘을 '최소 신장 트리 알고리즘'이라고 한다. 대표적인 최소 신장 트리 알고리즘으로는 크루스칼(Kruskal Algorithm)이 있다.
- 크루스칼 알고리즘을 사용하면 가장 적은 비용으로 모든 노드를 연결할 수 있는데 크루스칼 알고리즘은 그리디 알고리즘으로 분류된다.
- 먼저 모든 간선에 대하여 정렬을 수행한 뒤에 가장 거리가 짧은 간선부터 집합에 포함시키면 된다.
- 이때, 사이클을 발생시킬 수 있는 간선의 경우, 집합에 포함시키지 않는다.
  - 1. 간선 데이터를 비용에 따라 오름차순으로 정렬한다.
    2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인한다.
       1. 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킨다.
       2. 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않는다.
    3. 모든 간선에 대하여 2번의 과정을 반복한다.
- 최소 신장 트리는 일종의 트리 자료구조이므로, 최종적으로 신장 트리에 포함되는 간선의 개수가 '노드의 개수 - 1'과 같다는 특징이 있다.

```python
# 크루스칼 알고리즘 소스코드

def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

v, e = map(int, input().split())
parent = [0] * (v + 1)

edges = []
result = 0

for i in range(1, v + 1):
    parent[i] = i

for _ in range(e):
    a, b, cost = map(int, input().split())
    edges.append((cost, a, b))

edges.sort()

for edge in edges:
    cost, a, b = edge
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent, a, b)
        result += cost

print(result)

# 입력
7 9
1 2 29 
1 5 75
2 3 35
2 6 34
3 4 7
4 6 23
4 7 13
5 6 53
6 7 25
# 결과
159
```



- 크루스칼 알고리즘의 시간 복잡도
  - 간선의 개수가 E개일 떄, O(ElogE)의 시간 복잡도를 가진다. 왜냐하면 크루스칼 알고리즘에서 시간이 가장 오래 걸리는 부분이 간선을 정렬하는 작업이며, E개의 데이터를 정렬했을 때의 시간 복잡도는 O(ElogE)이기 때문이다.





### 위상 정렬

- 위상 정렬(Topology Sort)은 정렬 알고리즘의 일종이다.
- 위상 정렬은 순서가 정해져 있는 일련의 작업을 차례대로 수행해야 할 때 사용할 수 있는 알고리즘이다.
- 위상 정렬이란 방향 그래프의 모든 노드를 '방향성에 거스르지 않도록 순서대로 나열하는 것'이다.
- 다시 말해 그래프상에서 선후 관계가 있다면, 위상 정렬을 수행하여 모든 선후 관계를 지키는 전체 순서를 계산할 수 있다.
- 진입차수(Indegree)
  - 진입차수란 특정한 노드로 '들아오는' 간선의 개수를 의미한다.
- 위상 정렬 알고리즘
  - 1. 진입차수가 0인 노드를 큐에 넣는다.
    2. 큐가 빌 때까지 다음의 과정을 반복한다.
       1. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.
       2. 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.
  - 이때 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존해단다고 판달할 수 있다.
  - 위 과정을 수행하는 동안 큐에서 빠져나간 노드를 순서대로 출력하면, 그것이 바로 위상 정렬을 수행한 결과가 된다.
  - 위상 정렬의 답안은 여러 가지가 될 수 있다는 점이 특징이다. 한 단계에서 큐에 새롭게 들어가는 원소가 2개 이상인 경우

```python
from collections import deque

v, e = map(int, input().split())
indegree = [0] * (v + 1)
graph = [[] for i in range(v + 1)]

for _ in range(e):
    a, b = map(int, input().split())
    graph[a].append(b)
    indegree[b] += 1

def topology_sort():
    result = []
    q = deque()

    for i in range(1, v + 1):
        if indegree[i] == 0:
            q.append(i)

    while q:
        now = q.popleft()
        result.append(now)

        for i in graph[now]:
            indegree[i] -= 1
            if indegree[i] == 0:
                q.append(i)

    for i in result:
        print(i, end=' ')

topology_sort()

# 입력
7 8
1 2
1 5
2 3
2 6
3 4
4 7
5 6
6 4
# 결과
1 2 5 3 6 4 7
```



- 위상 정렬의 시간 복잡도
  - 위상 정렬의 시간 복잡도는 O(V + E)이다. 노드와 간선을 모두 확인한다는 측면에서 O(V + E)의 시간이 소요되는 것이다.